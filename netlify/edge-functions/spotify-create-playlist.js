import { findPlaylistsForGenre } from "./utils/find-playlists-for-genre.js";
import { getSpotifyUserId } from "./utils/get-spotify-user-id.js";

function createPlaylistDescription(playlists) {
  const ids = playlists.map((p) => p.playlistId);

  const names = playlists.map((p) => `'${p.name}'`);

  return `Playlist generated by discover-mix, which includes ${names.join(
    ", "
  )}. Playlist IDs: ${ids.join(" ")}`;
}

async function getPlaylistData(playlistId, spotifyAccessToken) {
  const responseJson = await fetch(
    `https://api.spotify.com/v1/playlists/${playlistId}`,
    {
      headers: {
        Authorization: `Bearer ${spotifyAccessToken}`,
      },
    }
  ).then((r) => r.json());

  const name = responseJson.name;
  let tracks = responseJson.tracks.items.map((t) => t.track);
  let nextUrl = responseJson.tracks.next;

  while (nextUrl) {
    const tracksResponse = await fetch(nextUrl, {
      headers: {
        Authorization: `Bearer ${spotifyAccessToken}`,
      },
    }).then((r) => r.json());

    tracks = [...tracks, ...tracksResponse.items.map((t) => t.track)];

    nextUrl = tracksResponse.next;
  }

  return { playlistId, name, tracks };
}

async function createPlaylist(
  spotifyUserId,
  spotifyAccessToken,
  name,
  trackIds,
  description
) {
  let tracksToAdd = [...trackIds];

  const createResponse = await fetch(
    `https://api.spotify.com/v1/users/${spotifyUserId}/playlists`,
    {
      method: "POST",
      headers: {
        Authorization: `Bearer ${spotifyAccessToken}`,
      },
      body: JSON.stringify({
        name,
        description,
        public: false,
      }),
    }
  );

  if (createResponse.ok) {
    const createResponseJson = await createResponse.json();
    console.log(createResponseJson);

    const newPlaylistId = createResponseJson.id;

    while (tracksToAdd.length > 0) {
      await fetch(
        `https://api.spotify.com/v1/playlists/${newPlaylistId}/tracks`,
        {
          method: "POST",
          body: JSON.stringify({
            uris: tracksToAdd.slice(0, 100).map((id) => `spotify:track:${id}`),
          }),
          headers: {
            Authorization: `Bearer ${spotifyAccessToken}`,
          },
        }
      );

      tracksToAdd = tracksToAdd.slice(100);
    }

    return newPlaylistId;
  }
}

export default async function (request, context) {
  // read the name and the playlist IDs from the posted data

  const formData = await request.formData();
  const playlistName = formData.get("name");
  const genres = formData.getAll("genre");
  const playlistTypes = formData.getAll("playlist-type");

  const spotifyAccessToken = context.cookies.get("spotify-access-token");

  try {
    // we need to get the playlist IDs for the genres
    const genrePlaylists = await Promise.all(
      genres.map((genreName) =>
        findPlaylistsForGenre({
          genre: genreName,
          spotifyAccessToken,
        })
      )
    );

    // filter to only include ones that match the type
    const playlistIds = genrePlaylists
      .flat()
      .filter((p) => playlistTypes.includes(p.type))
      .map((p) => p.id);

    const spotifyUserId = await getSpotifyUserId({ spotifyAccessToken });

    // TODO: maybe save user ID in cookie? Does it matter?

    const allData = await Promise.all(
      playlistIds.map((id) => getPlaylistData(id, spotifyAccessToken))
    );

    const allTracks = allData.map((playlistData) => playlistData.tracks);

    const allTrackIds = allTracks.flat().map((t) => t.id);

    const allUniqueTracks = Array.from(new Set(allTrackIds));

    // return context.json(allUniqueTracks);

    const description = createPlaylistDescription(allData);

    const newPlaylistId = await createPlaylist(
      spotifyUserId,
      spotifyAccessToken,
      `ðŸ¤– ${playlistName}`,
      allUniqueTracks,
      description
    );

    return context.json({
      status: "created",
      playlistName,
      url: `spotify:playlist:${newPlaylistId}`,
    });
  } catch (err) {
    console.log("Caught an error!");
    console.log(err);
    return context.json({
      status: "error",
      message: err,
    });
  }
}
